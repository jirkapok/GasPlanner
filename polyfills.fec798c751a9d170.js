"use strict";(self.webpackChunkplanner=self.webpackChunkplanner||[]).push([[429],{159:(Wt,jn,Wn)=>{class Dg extends Error{constructor(e){super(`No translation found for ${Vl(e)}.`),this.parsedMessage=e,this.type="MissingTranslationError"}}const No=function(s,...e){if(No.translate){const n=No.translate(s,e);s=n[0],e=n[1]}let t=ql(s[0],s.raw[0]);for(let n=1;n<s.length;n++)t+=e[n-1]+ql(s[n],s.raw[n]);return t};function ql(s,e){return":"===e.charAt(0)?s.substring(function Ol(s,e){for(let t=1,n=1;t<s.length;t++,n++)if("\\"===e[n])n++;else if(":"===s[t])return t;throw new Error(`Unterminated $localize metadata block in "${e}".`)}(s,e)+1):s}(()=>typeof globalThis<"u"&&globalThis||typeof global<"u"&&global||typeof window<"u"&&window||typeof self<"u"&&typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope&&self)().$localize=No,Wn(583)},583:()=>{!function(h){const g=h.performance;function x(ce){g&&g.mark&&g.mark(ce)}function y(ce,G){g&&g.measure&&g.measure(ce,G)}x("Zone");const T=h.__Zone_symbol_prefix||"__zone_symbol__";function I(ce){return T+ce}const M=!0===h[I("forceDuplicateZoneCheck")];if(h.Zone){if(M||"function"!=typeof h.Zone.__symbol__)throw new Error("Zone already loaded.");return h.Zone}let R=(()=>{class ce{constructor(d,E){this._parent=d,this._name=E?E.name||"unnamed":"<root>",this._properties=E&&E.properties||{},this._zoneDelegate=new Q(this,this._parent&&this._parent._zoneDelegate,E)}static assertZonePatched(){if(h.Promise!==gt.ZoneAwarePromise)throw new Error("Zone.js has detected that ZoneAwarePromise `(window|global).Promise` has been overwritten.\nMost likely cause is that a Promise polyfill has been loaded after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. If you must load one, do so before loading zone.js.)")}static get root(){let d=ce.current;for(;d.parent;)d=d.parent;return d}static get current(){return ke.zone}static get currentTask(){return vt}static __load_patch(d,E,q=!1){if(gt.hasOwnProperty(d)){if(!q&&M)throw Error("Already loaded patch: "+d)}else if(!h["__Zone_disable_"+d]){const ee="Zone:"+d;x(ee),gt[d]=E(h,ce,De),y(ee,ee)}}get parent(){return this._parent}get name(){return this._name}get(d){const E=this.getZoneWith(d);if(E)return E._properties[d]}getZoneWith(d){let E=this;for(;E;){if(E._properties.hasOwnProperty(d))return E;E=E._parent}return null}fork(d){if(!d)throw new Error("ZoneSpec required!");return this._zoneDelegate.fork(this,d)}wrap(d,E){if("function"!=typeof d)throw new Error("Expecting function got: "+d);const q=this._zoneDelegate.intercept(this,d,E),ee=this;return function(){return ee.runGuarded(q,this,arguments,E)}}run(d,E,q,ee){ke={parent:ke,zone:this};try{return this._zoneDelegate.invoke(this,d,E,q,ee)}finally{ke=ke.parent}}runGuarded(d,E=null,q,ee){ke={parent:ke,zone:this};try{try{return this._zoneDelegate.invoke(this,d,E,q,ee)}catch(Le){if(this._zoneDelegate.handleError(this,Le))throw Le}}finally{ke=ke.parent}}runTask(d,E,q){if(d.zone!=this)throw new Error("A task can only be run in the zone of creation! (Creation: "+(d.zone||Be).name+"; Execution: "+this.name+")");if(d.state===ge&&(d.type===Je||d.type===re))return;const ee=d.state!=W;ee&&d._transitionTo(W,ve),d.runCount++;const Le=vt;vt=d,ke={parent:ke,zone:this};try{d.type==re&&d.data&&!d.data.isPeriodic&&(d.cancelFn=void 0);try{return this._zoneDelegate.invokeTask(this,d,E,q)}catch(C){if(this._zoneDelegate.handleError(this,C))throw C}}finally{d.state!==ge&&d.state!==B&&(d.type==Je||d.data&&d.data.isPeriodic?ee&&d._transitionTo(ve,W):(d.runCount=0,this._updateTaskCount(d,-1),ee&&d._transitionTo(ge,W,ge))),ke=ke.parent,vt=Le}}scheduleTask(d){if(d.zone&&d.zone!==this){let q=this;for(;q;){if(q===d.zone)throw Error(`can not reschedule task to ${this.name} which is descendants of the original zone ${d.zone.name}`);q=q.parent}}d._transitionTo(ye,ge);const E=[];d._zoneDelegates=E,d._zone=this;try{d=this._zoneDelegate.scheduleTask(this,d)}catch(q){throw d._transitionTo(B,ye,ge),this._zoneDelegate.handleError(this,q),q}return d._zoneDelegates===E&&this._updateTaskCount(d,1),d.state==ye&&d._transitionTo(ve,ye),d}scheduleMicroTask(d,E,q,ee){return this.scheduleTask(new Z(de,d,E,q,ee,void 0))}scheduleMacroTask(d,E,q,ee,Le){return this.scheduleTask(new Z(re,d,E,q,ee,Le))}scheduleEventTask(d,E,q,ee,Le){return this.scheduleTask(new Z(Je,d,E,q,ee,Le))}cancelTask(d){if(d.zone!=this)throw new Error("A task can only be cancelled in the zone of creation! (Creation: "+(d.zone||Be).name+"; Execution: "+this.name+")");d._transitionTo(_e,ve,W);try{this._zoneDelegate.cancelTask(this,d)}catch(E){throw d._transitionTo(B,_e),this._zoneDelegate.handleError(this,E),E}return this._updateTaskCount(d,-1),d._transitionTo(ge,_e),d.runCount=0,d}_updateTaskCount(d,E){const q=d._zoneDelegates;-1==E&&(d._zoneDelegates=null);for(let ee=0;ee<q.length;ee++)q[ee]._updateTaskCount(d.type,E)}}return ce.__symbol__=I,ce})();const _={name:"",onHasTask:(ce,G,d,E)=>ce.hasTask(d,E),onScheduleTask:(ce,G,d,E)=>ce.scheduleTask(d,E),onInvokeTask:(ce,G,d,E,q,ee)=>ce.invokeTask(d,E,q,ee),onCancelTask:(ce,G,d,E)=>ce.cancelTask(d,E)};class Q{constructor(G,d,E){this._taskCounts={microTask:0,macroTask:0,eventTask:0},this.zone=G,this._parentDelegate=d,this._forkZS=E&&(E&&E.onFork?E:d._forkZS),this._forkDlgt=E&&(E.onFork?d:d._forkDlgt),this._forkCurrZone=E&&(E.onFork?this.zone:d._forkCurrZone),this._interceptZS=E&&(E.onIntercept?E:d._interceptZS),this._interceptDlgt=E&&(E.onIntercept?d:d._interceptDlgt),this._interceptCurrZone=E&&(E.onIntercept?this.zone:d._interceptCurrZone),this._invokeZS=E&&(E.onInvoke?E:d._invokeZS),this._invokeDlgt=E&&(E.onInvoke?d:d._invokeDlgt),this._invokeCurrZone=E&&(E.onInvoke?this.zone:d._invokeCurrZone),this._handleErrorZS=E&&(E.onHandleError?E:d._handleErrorZS),this._handleErrorDlgt=E&&(E.onHandleError?d:d._handleErrorDlgt),this._handleErrorCurrZone=E&&(E.onHandleError?this.zone:d._handleErrorCurrZone),this._scheduleTaskZS=E&&(E.onScheduleTask?E:d._scheduleTaskZS),this._scheduleTaskDlgt=E&&(E.onScheduleTask?d:d._scheduleTaskDlgt),this._scheduleTaskCurrZone=E&&(E.onScheduleTask?this.zone:d._scheduleTaskCurrZone),this._invokeTaskZS=E&&(E.onInvokeTask?E:d._invokeTaskZS),this._invokeTaskDlgt=E&&(E.onInvokeTask?d:d._invokeTaskDlgt),this._invokeTaskCurrZone=E&&(E.onInvokeTask?this.zone:d._invokeTaskCurrZone),this._cancelTaskZS=E&&(E.onCancelTask?E:d._cancelTaskZS),this._cancelTaskDlgt=E&&(E.onCancelTask?d:d._cancelTaskDlgt),this._cancelTaskCurrZone=E&&(E.onCancelTask?this.zone:d._cancelTaskCurrZone),this._hasTaskZS=null,this._hasTaskDlgt=null,this._hasTaskDlgtOwner=null,this._hasTaskCurrZone=null;const q=E&&E.onHasTask;(q||d&&d._hasTaskZS)&&(this._hasTaskZS=q?E:_,this._hasTaskDlgt=d,this._hasTaskDlgtOwner=this,this._hasTaskCurrZone=G,E.onScheduleTask||(this._scheduleTaskZS=_,this._scheduleTaskDlgt=d,this._scheduleTaskCurrZone=this.zone),E.onInvokeTask||(this._invokeTaskZS=_,this._invokeTaskDlgt=d,this._invokeTaskCurrZone=this.zone),E.onCancelTask||(this._cancelTaskZS=_,this._cancelTaskDlgt=d,this._cancelTaskCurrZone=this.zone))}fork(G,d){return this._forkZS?this._forkZS.onFork(this._forkDlgt,this.zone,G,d):new R(G,d)}intercept(G,d,E){return this._interceptZS?this._interceptZS.onIntercept(this._interceptDlgt,this._interceptCurrZone,G,d,E):d}invoke(G,d,E,q,ee){return this._invokeZS?this._invokeZS.onInvoke(this._invokeDlgt,this._invokeCurrZone,G,d,E,q,ee):d.apply(E,q)}handleError(G,d){return!this._handleErrorZS||this._handleErrorZS.onHandleError(this._handleErrorDlgt,this._handleErrorCurrZone,G,d)}scheduleTask(G,d){let E=d;if(this._scheduleTaskZS)this._hasTaskZS&&E._zoneDelegates.push(this._hasTaskDlgtOwner),E=this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt,this._scheduleTaskCurrZone,G,d),E||(E=d);else if(d.scheduleFn)d.scheduleFn(d);else{if(d.type!=de)throw new Error("Task is missing scheduleFn.");se(d)}return E}invokeTask(G,d,E,q){return this._invokeTaskZS?this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt,this._invokeTaskCurrZone,G,d,E,q):d.callback.apply(E,q)}cancelTask(G,d){let E;if(this._cancelTaskZS)E=this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt,this._cancelTaskCurrZone,G,d);else{if(!d.cancelFn)throw Error("Task is not cancelable");E=d.cancelFn(d)}return E}hasTask(G,d){try{this._hasTaskZS&&this._hasTaskZS.onHasTask(this._hasTaskDlgt,this._hasTaskCurrZone,G,d)}catch(E){this.handleError(G,E)}}_updateTaskCount(G,d){const E=this._taskCounts,q=E[G],ee=E[G]=q+d;if(ee<0)throw new Error("More tasks executed then were scheduled.");0!=q&&0!=ee||this.hasTask(this.zone,{microTask:E.microTask>0,macroTask:E.macroTask>0,eventTask:E.eventTask>0,change:G})}}class Z{constructor(G,d,E,q,ee,Le){if(this._zone=null,this.runCount=0,this._zoneDelegates=null,this._state="notScheduled",this.type=G,this.source=d,this.data=q,this.scheduleFn=ee,this.cancelFn=Le,!E)throw new Error("callback is not defined");this.callback=E;const C=this;this.invoke=G===Je&&q&&q.useG?Z.invokeTask:function(){return Z.invokeTask.call(h,C,this,arguments)}}static invokeTask(G,d,E){G||(G=this),ze++;try{return G.runCount++,G.zone.runTask(G,d,E)}finally{1==ze&&$(),ze--}}get zone(){return this._zone}get state(){return this._state}cancelScheduleRequest(){this._transitionTo(ge,ye)}_transitionTo(G,d,E){if(this._state!==d&&this._state!==E)throw new Error(`${this.type} '${this.source}': can not transition to '${G}', expecting state '${d}'${E?" or '"+E+"'":""}, was '${this._state}'.`);this._state=G,G==ge&&(this._zoneDelegates=null)}toString(){return this.data&&typeof this.data.handleId<"u"?this.data.handleId.toString():Object.prototype.toString.call(this)}toJSON(){return{type:this.type,state:this.state,source:this.source,zone:this.zone.name,runCount:this.runCount}}}const ne=I("setTimeout"),U=I("Promise"),ae=I("then");let qe,we=[],k=!1;function Ie(ce){if(qe||h[U]&&(qe=h[U].resolve(0)),qe){let G=qe[ae];G||(G=qe.then),G.call(qe,ce)}else h[ne](ce,0)}function se(ce){0===ze&&0===we.length&&Ie($),ce&&we.push(ce)}function $(){if(!k){for(k=!0;we.length;){const ce=we;we=[];for(let G=0;G<ce.length;G++){const d=ce[G];try{d.zone.runTask(d,null,null)}catch(E){De.onUnhandledError(E)}}}De.microtaskDrainDone(),k=!1}}const Be={name:"NO ZONE"},ge="notScheduled",ye="scheduling",ve="scheduled",W="running",_e="canceling",B="unknown",de="microTask",re="macroTask",Je="eventTask",gt={},De={symbol:I,currentZoneFrame:()=>ke,onUnhandledError:Ne,microtaskDrainDone:Ne,scheduleMicroTask:se,showUncaughtError:()=>!R[I("ignoreConsoleErrorUncaughtError")],patchEventTarget:()=>[],patchOnProperties:Ne,patchMethod:()=>Ne,bindArguments:()=>[],patchThen:()=>Ne,patchMacroTask:()=>Ne,patchEventPrototype:()=>Ne,isIEOrEdge:()=>!1,getGlobalObjects:()=>{},ObjectDefineProperty:()=>Ne,ObjectGetOwnPropertyDescriptor:()=>{},ObjectCreate:()=>{},ArraySlice:()=>[],patchClass:()=>Ne,wrapWithCurrentZone:()=>Ne,filterProperties:()=>[],attachOriginToPatched:()=>Ne,_redefineProperty:()=>Ne,patchCallbacks:()=>Ne,nativeScheduleMicroTask:Ie};let ke={parent:null,zone:new R(null,null)},vt=null,ze=0;function Ne(){}y("Zone","Zone"),h.Zone=R}(typeof window<"u"&&window||typeof self<"u"&&self||global);const Wt=Object.getOwnPropertyDescriptor,jn=Object.defineProperty,Wn=Object.getPrototypeOf,Gn=Object.create,Ot=Array.prototype.slice,pn="addEventListener",fs="removeEventListener",ms=Zone.__symbol__(pn),gs=Zone.__symbol__(fs),Ce="true",$e="false",Gt=Zone.__symbol__("");function In(h,g){return Zone.current.wrap(h,g)}function vs(h,g,x,y,T){return Zone.current.scheduleMacroTask(h,g,x,y,T)}const V=Zone.__symbol__,je=typeof window<"u",hn=je?window:void 0,He=je&&hn||"object"==typeof self&&self||global;function dn(h,g){for(let x=h.length-1;x>=0;x--)"function"==typeof h[x]&&(h[x]=In(h[x],g+"_"+x));return h}function zt(h){return!h||!1!==h.writable&&!("function"==typeof h.get&&typeof h.set>"u")}const Es=typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope,zn=!("nw"in He)&&typeof He.process<"u"&&"[object process]"==={}.toString.call(He.process),$t=!zn&&!Es&&!(!je||!hn.HTMLElement),ys=typeof He.process<"u"&&"[object process]"==={}.toString.call(He.process)&&!Es&&!(!je||!hn.HTMLElement),Dn={},Kn=function(h){if(!(h=h||He.event))return;let g=Dn[h.type];g||(g=Dn[h.type]=V("ON_PROPERTY"+h.type));const x=this||h.target||He,y=x[g];let T;return $t&&x===hn&&"error"===h.type?(T=y&&y.call(this,h.message,h.filename,h.lineno,h.colno,h.error),!0===T&&h.preventDefault()):(T=y&&y.apply(this,arguments),null!=T&&!T&&h.preventDefault()),T};function _s(h,g,x){let y=Wt(h,g);if(!y&&x&&Wt(x,g)&&(y={enumerable:!0,configurable:!0}),!y||!y.configurable)return;const T=V("on"+g+"patched");if(h.hasOwnProperty(T)&&h[T])return;delete y.writable,delete y.value;const I=y.get,M=y.set,R=g.substr(2);let _=Dn[R];_||(_=Dn[R]=V("ON_PROPERTY"+R)),y.set=function(Q){let Z=this;!Z&&h===He&&(Z=He),Z&&("function"==typeof Z[_]&&Z.removeEventListener(R,Kn),M&&M.call(Z,null),Z[_]=Q,"function"==typeof Q&&Z.addEventListener(R,Kn,!1))},y.get=function(){let Q=this;if(!Q&&h===He&&(Q=He),!Q)return null;const Z=Q[_];if(Z)return Z;if(I){let ne=I.call(this);if(ne)return y.set.call(this,ne),"function"==typeof Q.removeAttribute&&Q.removeAttribute(g),ne}return null},jn(h,g,y),h[T]=!0}function Ss(h,g,x){if(g)for(let y=0;y<g.length;y++)_s(h,"on"+g[y],x);else{const y=[];for(const T in h)"on"==T.substr(0,2)&&y.push(T);for(let T=0;T<y.length;T++)_s(h,y[T],x)}}const mt=V("originalInstance");function Nn(h){const g=He[h];if(!g)return;He[V(h)]=g,He[h]=function(){const T=dn(arguments,h);switch(T.length){case 0:this[mt]=new g;break;case 1:this[mt]=new g(T[0]);break;case 2:this[mt]=new g(T[0],T[1]);break;case 3:this[mt]=new g(T[0],T[1],T[2]);break;case 4:this[mt]=new g(T[0],T[1],T[2],T[3]);break;default:throw new Error("Arg list too long.")}},nt(He[h],g);const x=new g(function(){});let y;for(y in x)"XMLHttpRequest"===h&&"responseBlob"===y||function(T){"function"==typeof x[T]?He[h].prototype[T]=function(){return this[mt][T].apply(this[mt],arguments)}:jn(He[h].prototype,T,{set:function(I){"function"==typeof I?(this[mt][T]=In(I,h+"."+T),nt(this[mt][T],I)):this[mt][T]=I},get:function(){return this[mt][T]}})}(y);for(y in g)"prototype"!==y&&g.hasOwnProperty(y)&&(He[h][y]=g[y])}function Dt(h,g,x){let y=h;for(;y&&!y.hasOwnProperty(g);)y=Wn(y);!y&&h[g]&&(y=h);const T=V(g);let I=null;if(y&&(!(I=y[T])||!y.hasOwnProperty(T))&&(I=y[T]=y[g],zt(y&&Wt(y,g)))){const R=x(I,T,g);y[g]=function(){return R(this,arguments)},nt(y[g],I)}return I}function Jr(h,g,x){let y=null;function T(I){const M=I.data;return M.args[M.cbIdx]=function(){I.invoke.apply(this,arguments)},y.apply(M.target,M.args),I}y=Dt(h,g,I=>function(M,R){const _=x(M,R);return _.cbIdx>=0&&"function"==typeof R[_.cbIdx]?vs(_.name,R[_.cbIdx],_,T):I.apply(M,R)})}function nt(h,g){h[V("OriginalDelegate")]=g}let er=!1,Zn=!1;function nr(){if(er)return Zn;er=!0;try{const h=hn.navigator.userAgent;(-1!==h.indexOf("MSIE ")||-1!==h.indexOf("Trident/")||-1!==h.indexOf("Edge/"))&&(Zn=!0)}catch{}return Zn}Zone.__load_patch("ZoneAwarePromise",(h,g,x)=>{const y=Object.getOwnPropertyDescriptor,T=Object.defineProperty,M=x.symbol,R=[],_=!0===h[M("DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION")],Q=M("Promise"),Z=M("then");x.onUnhandledError=C=>{if(x.showUncaughtError()){const D=C&&C.rejection;D?console.error("Unhandled Promise rejection:",D instanceof Error?D.message:D,"; Zone:",C.zone.name,"; Task:",C.task&&C.task.source,"; Value:",D,D instanceof Error?D.stack:void 0):console.error(C)}},x.microtaskDrainDone=()=>{for(;R.length;){const C=R.shift();try{C.zone.runGuarded(()=>{throw C.throwOriginal?C.rejection:C})}catch(D){ae(D)}}};const U=M("unhandledPromiseRejectionHandler");function ae(C){x.onUnhandledError(C);try{const D=g[U];"function"==typeof D&&D.call(this,C)}catch{}}function we(C){return C&&C.then}function k(C){return C}function qe(C){return d.reject(C)}const Ie=M("state"),se=M("value"),$=M("finally"),Be=M("parentPromiseValue"),ge=M("parentPromiseState"),ve=null,W=!0,_e=!1;function de(C,D){return w=>{try{De(C,D,w)}catch(N){De(C,!1,N)}}}const gt=M("currentTaskTrace");function De(C,D,w){const N=function(){let C=!1;return function(w){return function(){C||(C=!0,w.apply(null,arguments))}}}();if(C===w)throw new TypeError("Promise resolved with itself");if(C[Ie]===ve){let Y=null;try{("object"==typeof w||"function"==typeof w)&&(Y=w&&w.then)}catch(J){return N(()=>{De(C,!1,J)})(),C}if(D!==_e&&w instanceof d&&w.hasOwnProperty(Ie)&&w.hasOwnProperty(se)&&w[Ie]!==ve)vt(w),De(C,w[Ie],w[se]);else if(D!==_e&&"function"==typeof Y)try{Y.call(w,N(de(C,D)),N(de(C,!1)))}catch(J){N(()=>{De(C,!1,J)})()}else{C[Ie]=D;const J=C[se];if(C[se]=w,C[$]===$&&D===W&&(C[Ie]=C[ge],C[se]=C[Be]),D===_e&&w instanceof Error){const K=g.currentTask&&g.currentTask.data&&g.currentTask.data.__creationTrace__;K&&T(w,gt,{configurable:!0,enumerable:!1,writable:!0,value:K})}for(let K=0;K<J.length;)ze(C,J[K++],J[K++],J[K++],J[K++]);if(0==J.length&&D==_e){C[Ie]=0;let K=w;try{throw new Error("Uncaught (in promise): "+function I(C){return C&&C.toString===Object.prototype.toString?(C.constructor&&C.constructor.name||"")+": "+JSON.stringify(C):C?C.toString():Object.prototype.toString.call(C)}(w)+(w&&w.stack?"\n"+w.stack:""))}catch(ie){K=ie}_&&(K.throwOriginal=!0),K.rejection=w,K.promise=C,K.zone=g.current,K.task=g.currentTask,R.push(K),x.scheduleMicroTask()}}}return C}const ke=M("rejectionHandledHandler");function vt(C){if(0===C[Ie]){try{const D=g[ke];D&&"function"==typeof D&&D.call(this,{rejection:C[se],promise:C})}catch{}C[Ie]=_e;for(let D=0;D<R.length;D++)C===R[D].promise&&R.splice(D,1)}}function ze(C,D,w,N,Y){vt(C);const J=C[Ie],K=J?"function"==typeof N?N:k:"function"==typeof Y?Y:qe;D.scheduleMicroTask("Promise.then",()=>{try{const ie=C[se],oe=!!w&&$===w[$];oe&&(w[Be]=ie,w[ge]=J);const H=D.run(K,void 0,oe&&K!==qe&&K!==k?[]:[ie]);De(w,!0,H)}catch(ie){De(w,!1,ie)}},w)}const ce=function(){},G=h.AggregateError;class d{static toString(){return"function ZoneAwarePromise() { [native code] }"}static resolve(D){return De(new this(null),W,D)}static reject(D){return De(new this(null),_e,D)}static any(D){if(!D||"function"!=typeof D[Symbol.iterator])return Promise.reject(new G([],"All promises were rejected"));const w=[];let N=0;try{for(let K of D)N++,w.push(d.resolve(K))}catch{return Promise.reject(new G([],"All promises were rejected"))}if(0===N)return Promise.reject(new G([],"All promises were rejected"));let Y=!1;const J=[];return new d((K,ie)=>{for(let oe=0;oe<w.length;oe++)w[oe].then(H=>{Y||(Y=!0,K(H))},H=>{J.push(H),N--,0===N&&(Y=!0,ie(new G(J,"All promises were rejected")))})})}static race(D){let w,N,Y=new this((ie,oe)=>{w=ie,N=oe});function J(ie){w(ie)}function K(ie){N(ie)}for(let ie of D)we(ie)||(ie=this.resolve(ie)),ie.then(J,K);return Y}static all(D){return d.allWithCallback(D)}static allSettled(D){return(this&&this.prototype instanceof d?this:d).allWithCallback(D,{thenCallback:N=>({status:"fulfilled",value:N}),errorCallback:N=>({status:"rejected",reason:N})})}static allWithCallback(D,w){let N,Y,J=new this((H,xe)=>{N=H,Y=xe}),K=2,ie=0;const oe=[];for(let H of D){we(H)||(H=this.resolve(H));const xe=ie;try{H.then(Te=>{oe[xe]=w?w.thenCallback(Te):Te,K--,0===K&&N(oe)},Te=>{w?(oe[xe]=w.errorCallback(Te),K--,0===K&&N(oe)):Y(Te)})}catch(Te){Y(Te)}K++,ie++}return K-=2,0===K&&N(oe),J}constructor(D){const w=this;if(!(w instanceof d))throw new Error("Must be an instanceof Promise.");w[Ie]=ve,w[se]=[];try{D&&D(de(w,W),de(w,_e))}catch(N){De(w,!1,N)}}get[Symbol.toStringTag](){return"Promise"}get[Symbol.species](){return d}then(D,w){let N=this.constructor[Symbol.species];(!N||"function"!=typeof N)&&(N=this.constructor||d);const Y=new N(ce),J=g.current;return this[Ie]==ve?this[se].push(J,Y,D,w):ze(this,J,Y,D,w),Y}catch(D){return this.then(null,D)}finally(D){let w=this.constructor[Symbol.species];(!w||"function"!=typeof w)&&(w=d);const N=new w(ce);N[$]=$;const Y=g.current;return this[Ie]==ve?this[se].push(Y,N,D,D):ze(this,Y,N,D,D),N}}d.resolve=d.resolve,d.reject=d.reject,d.race=d.race,d.all=d.all;const E=h[Q]=h.Promise;h.Promise=d;const q=M("thenPatched");function ee(C){const D=C.prototype,w=y(D,"then");if(w&&(!1===w.writable||!w.configurable))return;const N=D.then;D[Z]=N,C.prototype.then=function(Y,J){return new d((ie,oe)=>{N.call(this,ie,oe)}).then(Y,J)},C[q]=!0}return x.patchThen=ee,E&&(ee(E),Dt(h,"fetch",C=>function Le(C){return function(D,w){let N=C.apply(D,w);if(N instanceof d)return N;let Y=N.constructor;return Y[q]||ee(Y),N}}(C))),Promise[g.__symbol__("uncaughtPromiseErrors")]=R,d}),Zone.__load_patch("toString",h=>{const g=Function.prototype.toString,x=V("OriginalDelegate"),y=V("Promise"),T=V("Error"),I=function(){if("function"==typeof this){const Q=this[x];if(Q)return"function"==typeof Q?g.call(Q):Object.prototype.toString.call(Q);if(this===Promise){const Z=h[y];if(Z)return g.call(Z)}if(this===Error){const Z=h[T];if(Z)return g.call(Z)}}return g.call(this)};I[x]=g,Function.prototype.toString=I;const M=Object.prototype.toString;Object.prototype.toString=function(){return"function"==typeof Promise&&this instanceof Promise?"[object Promise]":M.call(this)}});let Kt=!1;if(typeof window<"u")try{const h=Object.defineProperty({},"passive",{get:function(){Kt=!0}});window.addEventListener("test",h,h),window.removeEventListener("test",h,h)}catch{Kt=!1}const Nt={useG:!0},Ve={},ws={},sr=new RegExp("^"+Gt+"(\\w+)(true|false)$"),Xn=V("propagationStopped");function rr(h,g){const x=(g?g(h):h)+$e,y=(g?g(h):h)+Ce,T=Gt+x,I=Gt+y;Ve[h]={},Ve[h][$e]=T,Ve[h][Ce]=I}function ei(h,g,x,y){const T=y&&y.add||pn,I=y&&y.rm||fs,M=y&&y.listeners||"eventListeners",R=y&&y.rmAll||"removeAllListeners",_=V(T),Q="."+T+":",Z="prependListener",ne="."+Z+":",U=function(se,$,Be){if(se.isRemoved)return;const ge=se.callback;let ye;"object"==typeof ge&&ge.handleEvent&&(se.callback=W=>ge.handleEvent(W),se.originalDelegate=ge);try{se.invoke(se,$,[Be])}catch(W){ye=W}const ve=se.options;return ve&&"object"==typeof ve&&ve.once&&$[I].call($,Be.type,se.originalDelegate?se.originalDelegate:se.callback,ve),ye};function ae(se,$,Be){if(!($=$||h.event))return;const ge=se||$.target||h,ye=ge[Ve[$.type][Be?Ce:$e]];if(ye){const ve=[];if(1===ye.length){const W=U(ye[0],ge,$);W&&ve.push(W)}else{const W=ye.slice();for(let _e=0;_e<W.length&&(!$||!0!==$[Xn]);_e++){const B=U(W[_e],ge,$);B&&ve.push(B)}}if(1===ve.length)throw ve[0];for(let W=0;W<ve.length;W++){const _e=ve[W];g.nativeScheduleMicroTask(()=>{throw _e})}}}const we=function(se){return ae(this,se,!1)},k=function(se){return ae(this,se,!0)};function qe(se,$){if(!se)return!1;let Be=!0;$&&void 0!==$.useG&&(Be=$.useG);const ge=$&&$.vh;let ye=!0;$&&void 0!==$.chkDup&&(ye=$.chkDup);let ve=!1;$&&void 0!==$.rt&&(ve=$.rt);let W=se;for(;W&&!W.hasOwnProperty(T);)W=Wn(W);if(!W&&se[T]&&(W=se),!W||W[_])return!1;const _e=$&&$.eventNameToString,B={},de=W[_]=W[T],re=W[V(I)]=W[I],Je=W[V(M)]=W[M],gt=W[V(R)]=W[R];let De;function ke(w,N){return!Kt&&"object"==typeof w&&w?!!w.capture:Kt&&N?"boolean"==typeof w?{capture:w,passive:!0}:w?"object"==typeof w&&!1!==w.passive?Object.assign(Object.assign({},w),{passive:!0}):w:{passive:!0}:w}$&&$.prepend&&(De=W[V($.prepend)]=W[$.prepend]);const d=Be?function(w){if(!B.isExisting)return de.call(B.target,B.eventName,B.capture?k:we,B.options)}:function(w){return de.call(B.target,B.eventName,w.invoke,B.options)},E=Be?function(w){if(!w.isRemoved){const N=Ve[w.eventName];let Y;N&&(Y=N[w.capture?Ce:$e]);const J=Y&&w.target[Y];if(J)for(let K=0;K<J.length;K++)if(J[K]===w){J.splice(K,1),w.isRemoved=!0,0===J.length&&(w.allRemoved=!0,w.target[Y]=null);break}}if(w.allRemoved)return re.call(w.target,w.eventName,w.capture?k:we,w.options)}:function(w){return re.call(w.target,w.eventName,w.invoke,w.options)},ee=$&&$.diff?$.diff:function(w,N){const Y=typeof N;return"function"===Y&&w.callback===N||"object"===Y&&w.originalDelegate===N},Le=Zone[V("UNPATCHED_EVENTS")],C=h[V("PASSIVE_EVENTS")],D=function(w,N,Y,J,K=!1,ie=!1){return function(){const oe=this||h;let H=arguments[0];$&&$.transferEventName&&(H=$.transferEventName(H));let xe=arguments[1];if(!xe)return w.apply(this,arguments);if(zn&&"uncaughtException"===H)return w.apply(this,arguments);let Te=!1;if("function"!=typeof xe){if(!xe.handleEvent)return w.apply(this,arguments);Te=!0}if(ge&&!ge(w,xe,oe,arguments))return;const st=Kt&&!!C&&-1!==C.indexOf(H),Ue=ke(arguments[2],st);if(Le)for(let te=0;te<Le.length;te++)if(H===Le[te])return st?w.call(oe,H,xe,Ue):w.apply(this,arguments);const fn=!!Ue&&("boolean"==typeof Ue||Ue.capture),wt=!(!Ue||"object"!=typeof Ue)&&Ue.once,Fe=Zone.current;let mn=Ve[H];mn||(rr(H,_e),mn=Ve[H]);const ar=mn[fn?Ce:$e];let ue,gn=oe[ar],Ts=!1;if(gn){if(Ts=!0,ye)for(let te=0;te<gn.length;te++)if(ee(gn[te],xe))return}else gn=oe[ar]=[];const P=oe.constructor.name,ur=ws[P];ur&&(ue=ur[H]),ue||(ue=P+N+(_e?_e(H):H)),B.options=Ue,wt&&(B.options.once=!1),B.target=oe,B.capture=fn,B.eventName=H,B.isExisting=Ts;const Re=Be?Nt:void 0;Re&&(Re.taskData=B);const lt=Fe.scheduleEventTask(ue,xe,Re,Y,J);return B.target=null,Re&&(Re.taskData=null),wt&&(Ue.once=!0),!Kt&&"boolean"==typeof lt.options||(lt.options=Ue),lt.target=oe,lt.capture=fn,lt.eventName=H,Te&&(lt.originalDelegate=xe),ie?gn.unshift(lt):gn.push(lt),K?oe:void 0}};return W[T]=D(de,Q,d,E,ve),De&&(W[Z]=D(De,ne,function(w){return De.call(B.target,B.eventName,w.invoke,B.options)},E,ve,!0)),W[I]=function(){const w=this||h;let N=arguments[0];$&&$.transferEventName&&(N=$.transferEventName(N));const Y=arguments[2],J=!!Y&&("boolean"==typeof Y||Y.capture),K=arguments[1];if(!K)return re.apply(this,arguments);if(ge&&!ge(re,K,w,arguments))return;const ie=Ve[N];let oe;ie&&(oe=ie[J?Ce:$e]);const H=oe&&w[oe];if(H)for(let xe=0;xe<H.length;xe++){const Te=H[xe];if(ee(Te,K))return H.splice(xe,1),Te.isRemoved=!0,0===H.length&&(Te.allRemoved=!0,w[oe]=null,"string"==typeof N)&&(w[Gt+"ON_PROPERTY"+N]=null),Te.zone.cancelTask(Te),ve?w:void 0}return re.apply(this,arguments)},W[M]=function(){const w=this||h;let N=arguments[0];$&&$.transferEventName&&(N=$.transferEventName(N));const Y=[],J=xs(w,_e?_e(N):N);for(let K=0;K<J.length;K++){const ie=J[K];Y.push(ie.originalDelegate?ie.originalDelegate:ie.callback)}return Y},W[R]=function(){const w=this||h;let N=arguments[0];if(N){$&&$.transferEventName&&(N=$.transferEventName(N));const Y=Ve[N];if(Y){const ie=w[Y[$e]],oe=w[Y[Ce]];if(ie){const H=ie.slice();for(let xe=0;xe<H.length;xe++){const Te=H[xe];this[I].call(this,N,Te.originalDelegate?Te.originalDelegate:Te.callback,Te.options)}}if(oe){const H=oe.slice();for(let xe=0;xe<H.length;xe++){const Te=H[xe];this[I].call(this,N,Te.originalDelegate?Te.originalDelegate:Te.callback,Te.options)}}}}else{const Y=Object.keys(w);for(let J=0;J<Y.length;J++){const ie=sr.exec(Y[J]);let oe=ie&&ie[1];oe&&"removeListener"!==oe&&this[R].call(this,oe)}this[R].call(this,"removeListener")}if(ve)return this},nt(W[T],de),nt(W[I],re),gt&&nt(W[R],gt),Je&&nt(W[M],Je),!0}let Ie=[];for(let se=0;se<x.length;se++)Ie[se]=qe(x[se],y);return Ie}function xs(h,g){if(!g){const I=[];for(let M in h){const R=sr.exec(M);let _=R&&R[1];if(_&&(!g||_===g)){const Q=h[M];if(Q)for(let Z=0;Z<Q.length;Z++)I.push(Q[Z])}}return I}let x=Ve[g];x||(rr(g),x=Ve[g]);const y=h[x[$e]],T=h[x[Ce]];return y?T?y.concat(T):y.slice():T?T.slice():[]}function ti(h,g){const x=h.Event;x&&x.prototype&&g.patchMethod(x.prototype,"stopImmediatePropagation",y=>function(T,I){T[Xn]=!0,y&&y.apply(T,I)})}function ir(h,g,x,y,T){const I=Zone.__symbol__(y);if(g[I])return;const M=g[I]=g[y];g[y]=function(R,_,Q){return _&&_.prototype&&T.forEach(function(Z){const ne=`${x}.${y}::`+Z,U=_.prototype;if(U.hasOwnProperty(Z)){const ae=h.ObjectGetOwnPropertyDescriptor(U,Z);ae&&ae.value?(ae.value=h.wrapWithCurrentZone(ae.value,ne),h._redefineProperty(_.prototype,Z,ae)):U[Z]&&(U[Z]=h.wrapWithCurrentZone(U[Z],ne))}else U[Z]&&(U[Z]=h.wrapWithCurrentZone(U[Z],ne))}),M.call(g,R,_,Q)},h.attachOriginToPatched(g[y],M)}function or(h,g,x){if(!x||0===x.length)return g;const y=x.filter(I=>I.target===h);if(!y||0===y.length)return g;const T=y[0].ignoreProperties;return g.filter(I=>-1===T.indexOf(I))}function St(h,g,x,y){h&&Ss(h,or(h,g,x),y)}function Zt(h){return Object.getOwnPropertyNames(h).filter(g=>g.startsWith("on")&&g.length>2).map(g=>g.substring(2))}Zone.__load_patch("util",(h,g,x)=>{const y=Zt(h);x.patchOnProperties=Ss,x.patchMethod=Dt,x.bindArguments=dn,x.patchMacroTask=Jr;const T=g.__symbol__("BLACK_LISTED_EVENTS"),I=g.__symbol__("UNPATCHED_EVENTS");h[I]&&(h[T]=h[I]),h[T]&&(g[T]=g[I]=h[T]),x.patchEventPrototype=ti,x.patchEventTarget=ei,x.isIEOrEdge=nr,x.ObjectDefineProperty=jn,x.ObjectGetOwnPropertyDescriptor=Wt,x.ObjectCreate=Gn,x.ArraySlice=Ot,x.patchClass=Nn,x.wrapWithCurrentZone=In,x.filterProperties=or,x.attachOriginToPatched=nt,x._redefineProperty=Object.defineProperty,x.patchCallbacks=ir,x.getGlobalObjects=()=>({globalSources:ws,zoneSymbolEventNames:Ve,eventNames:y,isBrowser:$t,isMix:ys,isNode:zn,TRUE_STR:Ce,FALSE_STR:$e,ZONE_SYMBOL_PREFIX:Gt,ADD_EVENT_LISTENER_STR:pn,REMOVE_EVENT_LISTENER_STR:fs})});const ut=V("zoneTask");function Qe(h,g,x,y){let T=null,I=null;x+=y;const M={};function R(Q){const Z=Q.data;return Z.args[0]=function(){return Q.invoke.apply(this,arguments)},Z.handleId=T.apply(h,Z.args),Q}function _(Q){return I.call(h,Q.data.handleId)}T=Dt(h,g+=y,Q=>function(Z,ne){if("function"==typeof ne[0]){const U={isPeriodic:"Interval"===y,delay:"Timeout"===y||"Interval"===y?ne[1]||0:void 0,args:ne},ae=ne[0];ne[0]=function(){try{return ae.apply(this,arguments)}finally{U.isPeriodic||("number"==typeof U.handleId?delete M[U.handleId]:U.handleId&&(U.handleId[ut]=null))}};const we=vs(g,ne[0],U,R,_);if(!we)return we;const k=we.data.handleId;return"number"==typeof k?M[k]=we:k&&(k[ut]=we),k&&k.ref&&k.unref&&"function"==typeof k.ref&&"function"==typeof k.unref&&(we.ref=k.ref.bind(k),we.unref=k.unref.bind(k)),"number"==typeof k||k?k:we}return Q.apply(h,ne)}),I=Dt(h,x,Q=>function(Z,ne){const U=ne[0];let ae;"number"==typeof U?ae=M[U]:(ae=U&&U[ut],ae||(ae=U)),ae&&"string"==typeof ae.type?"notScheduled"!==ae.state&&(ae.cancelFn&&ae.data.isPeriodic||0===ae.runCount)&&("number"==typeof U?delete M[U]:U&&(U[ut]=null),ae.zone.cancelTask(ae)):Q.apply(h,ne)})}Zone.__load_patch("legacy",h=>{const g=h[Zone.__symbol__("legacyPatch")];g&&g()}),Zone.__load_patch("queueMicrotask",(h,g,x)=>{x.patchMethod(h,"queueMicrotask",y=>function(T,I){g.current.scheduleMicroTask("queueMicrotask",I[0])})}),Zone.__load_patch("timers",h=>{const g="set",x="clear";Qe(h,g,x,"Timeout"),Qe(h,g,x,"Interval"),Qe(h,g,x,"Immediate")}),Zone.__load_patch("requestAnimationFrame",h=>{Qe(h,"request","cancel","AnimationFrame"),Qe(h,"mozRequest","mozCancel","AnimationFrame"),Qe(h,"webkitRequest","webkitCancel","AnimationFrame")}),Zone.__load_patch("blocking",(h,g)=>{const x=["alert","prompt","confirm"];for(let y=0;y<x.length;y++)Dt(h,x[y],(I,M,R)=>function(_,Q){return g.current.run(I,h,Q,R)})}),Zone.__load_patch("EventTarget",(h,g,x)=>{(function Xt(h,g){g.patchEventPrototype(h,g)})(h,x),function si(h,g){if(Zone[g.symbol("patchEventTarget")])return;const{eventNames:x,zoneSymbolEventNames:y,TRUE_STR:T,FALSE_STR:I,ZONE_SYMBOL_PREFIX:M}=g.getGlobalObjects();for(let _=0;_<x.length;_++){const Q=x[_],U=M+(Q+I),ae=M+(Q+T);y[Q]={},y[Q][I]=U,y[Q][T]=ae}const R=h.EventTarget;R&&R.prototype&&g.patchEventTarget(h,g,[R&&R.prototype])}(h,x);const y=h.XMLHttpRequestEventTarget;y&&y.prototype&&x.patchEventTarget(h,x,[y.prototype])}),Zone.__load_patch("MutationObserver",(h,g,x)=>{Nn("MutationObserver"),Nn("WebKitMutationObserver")}),Zone.__load_patch("IntersectionObserver",(h,g,x)=>{Nn("IntersectionObserver")}),Zone.__load_patch("FileReader",(h,g,x)=>{Nn("FileReader")}),Zone.__load_patch("on_property",(h,g,x)=>{!function Se(h,g){if(zn&&!ys||Zone[h.symbol("patchEvents")])return;const x=g.__Zone_ignore_on_properties;let y=[];if($t){const T=window;y=y.concat(["Document","SVGElement","Element","HTMLElement","HTMLBodyElement","HTMLMediaElement","HTMLFrameSetElement","HTMLFrameElement","HTMLIFrameElement","HTMLMarqueeElement","Worker"]);const I=function tr(){try{const h=hn.navigator.userAgent;if(-1!==h.indexOf("MSIE ")||-1!==h.indexOf("Trident/"))return!0}catch{}return!1}()?[{target:T,ignoreProperties:["error"]}]:[];St(T,Zt(T),x&&x.concat(I),Wn(T))}y=y.concat(["XMLHttpRequest","XMLHttpRequestEventTarget","IDBIndex","IDBRequest","IDBOpenDBRequest","IDBDatabase","IDBTransaction","IDBCursor","WebSocket"]);for(let T=0;T<y.length;T++){const I=g[y[T]];I&&I.prototype&&St(I.prototype,Zt(I.prototype),x)}}(x,h)}),Zone.__load_patch("customElements",(h,g,x)=>{!function ni(h,g){const{isBrowser:x,isMix:y}=g.getGlobalObjects();(x||y)&&h.customElements&&"customElements"in h&&g.patchCallbacks(g,h.customElements,"customElements","define",["connectedCallback","disconnectedCallback","adoptedCallback","attributeChangedCallback"])}(h,x)}),Zone.__load_patch("XHR",(h,g)=>{!function _(Q){const Z=Q.XMLHttpRequest;if(!Z)return;const ne=Z.prototype;let ae=ne[ms],we=ne[gs];if(!ae){const B=Q.XMLHttpRequestEventTarget;if(B){const de=B.prototype;ae=de[ms],we=de[gs]}}const k="readystatechange",qe="scheduled";function Ie(B){const de=B.data,re=de.target;re[I]=!1,re[R]=!1;const Je=re[T];ae||(ae=re[ms],we=re[gs]),Je&&we.call(re,k,Je);const gt=re[T]=()=>{if(re.readyState===re.DONE)if(!de.aborted&&re[I]&&B.state===qe){const ke=re[g.__symbol__("loadfalse")];if(0!==re.status&&ke&&ke.length>0){const vt=B.invoke;B.invoke=function(){const ze=re[g.__symbol__("loadfalse")];for(let Ne=0;Ne<ze.length;Ne++)ze[Ne]===B&&ze.splice(Ne,1);!de.aborted&&B.state===qe&&vt.call(B)},ke.push(B)}else B.invoke()}else!de.aborted&&!1===re[I]&&(re[R]=!0)};return ae.call(re,k,gt),re[x]||(re[x]=B),W.apply(re,de.args),re[I]=!0,B}function se(){}function $(B){const de=B.data;return de.aborted=!0,_e.apply(de.target,de.args)}const Be=Dt(ne,"open",()=>function(B,de){return B[y]=0==de[2],B[M]=de[1],Be.apply(B,de)}),ye=V("fetchTaskAborting"),ve=V("fetchTaskScheduling"),W=Dt(ne,"send",()=>function(B,de){if(!0===g.current[ve]||B[y])return W.apply(B,de);{const re={target:B,url:B[M],isPeriodic:!1,args:de,aborted:!1},Je=vs("XMLHttpRequest.send",se,re,Ie,$);B&&!0===B[R]&&!re.aborted&&Je.state===qe&&Je.invoke()}}),_e=Dt(ne,"abort",()=>function(B,de){const re=function U(B){return B[x]}(B);if(re&&"string"==typeof re.type){if(null==re.cancelFn||re.data&&re.data.aborted)return;re.zone.cancelTask(re)}else if(!0===g.current[ye])return _e.apply(B,de)})}(h);const x=V("xhrTask"),y=V("xhrSync"),T=V("xhrListener"),I=V("xhrScheduled"),M=V("xhrURL"),R=V("xhrErrorBeforeScheduled")}),Zone.__load_patch("geolocation",h=>{h.navigator&&h.navigator.geolocation&&function Po(h,g){const x=h.constructor.name;for(let y=0;y<g.length;y++){const T=g[y],I=h[T];if(I){if(!zt(Wt(h,T)))continue;h[T]=(R=>{const _=function(){return R.apply(this,dn(arguments,x+"."+T))};return nt(_,R),_})(I)}}}(h.navigator.geolocation,["getCurrentPosition","watchPosition"])}),Zone.__load_patch("PromiseRejectionEvent",(h,g)=>{function x(y){return function(T){xs(h,y).forEach(M=>{const R=h.PromiseRejectionEvent;if(R){const _=new R(y,{promise:T.promise,reason:T.rejection});M.invoke(_)}})}}h.PromiseRejectionEvent&&(g[V("unhandledPromiseRejectionHandler")]=x("unhandledrejection"),g[V("rejectionHandledHandler")]=x("rejectionhandled"))})}},Wt=>{Wt(Wt.s=159)}]);