import { Precision } from './precision';
import { AlgorithmParams, BuhlmannAlgorithm } from './BuhlmannAlgorithm';
import { DepthConverter } from './depth-converter';
import { Diver } from './Diver';
import { Gases } from './Gases';
import { Options } from './Options';
import { CalculatedProfile } from './CalculatedProfile';
import { Segment, Segments } from './Segments';
import { Tank, Tanks } from './Tanks';
import { Time } from './Time';
import { BinaryIntervalSearch, SearchContext } from './BinaryIntervalSearch';
import { PlanFactory } from './PlanFactory';


class ConsumptionSegment {
    /** in seconds */
    public startTime = 0;
    /** in seconds */
    public endTime = 0;
    /** in meters */
    public averageDepth = 0;
    /** in meters */
    private _startDepth = 0;
    /** in meters */
    private _endDepth = 0;

    /**
     * @param duration in seconds
     * @param newDepth in meters
     * @param previousDepth in meters
     */
    private constructor(public duration: number, newDepth: number, previousDepth: number, averageDepth: number) {
        this.endTime = Precision.roundTwoDecimals(duration);
        this._endDepth = newDepth;
        this._startDepth = previousDepth;
        this.averageDepth = averageDepth;
    }

    /** in meters */
    public get startDepth(): number {
        return this._startDepth;
    }

    /** in meters */
    public get endDepth(): number {
        return this._endDepth;
    }

    public static fromSegment(segment: Segment): ConsumptionSegment {
        return new ConsumptionSegment(segment.duration, segment.endDepth, segment.startDepth, segment.averageDepth);
    }
}

export interface ConsumptionOptions {
    diver: Diver;
    /** Minimum tank reserve for first tank in bars */
    primaryTankReserve: number;
    /** Minimum tank reserve for all other stage tanks in bars */
    stageTankReserve: number;
}

/**
 * Calculates tank consumptions during the dive and related variables
 * (e.g. rock bottom, turn pressure, turn time)
 */
export class Consumption {
    /** Minimum bars to keep in first tank, even for shallow dives */
    public static readonly defaultPrimaryReserve = 30;
    /** Minimum bars to keep in stage tank, even for shallow dives */
    public static readonly defaultStageReserve = 20;

    constructor(private depthConverter: DepthConverter) { }

    private static calculateDecompression(segments: Segments, tanks: Tank[], options: Options): CalculatedProfile {
        const bGases = Gases.fromTanks(tanks);

        const algorithm = new BuhlmannAlgorithm();
        const segmentsCopy = segments.copy();
        const parameters = AlgorithmParams.forMultilevelDive(segmentsCopy, bGases, options);
        const profile = algorithm.decompression(parameters);
        return profile;
    }

    /**
     * Updates tanks consumption based on segments, also calculates emergency profile using the decompression algorithm.
     * So it is time consuming => Performance hit.
     * @param segments Profile generated by algorithm including user defined + generated ascent,
     *                 the array needs have at least 3 items (descent, swim, ascent).
     * @param options Not null profile behavior options.
     * @param tanks All tanks used to generate the profile, their gases need to fit all used in segments param
     * @param consumptionOptions Not null definition how to consume the gases.
     */
    public consumeFromTanks(segments: Segment[], options: Options, tanks: Tank[], consumptionOptions: ConsumptionOptions): void {
        if (segments.length < 2) {
            throw new Error('Profile needs to contain at least 2 segments.');
        }

        const emergencyAscent = PlanFactory.emergencyAscent(segments, options, tanks);
        this.consumeFromTanks2(segments, emergencyAscent, tanks, consumptionOptions);
    }

    /**
     * Updates tanks consumption based on segments, uses already calculated emergency ascent.
     * So it is time consuming => Performance hit.
     * @param segments Profile generated by algorithm including user defined + generated ascent,
     *                 the array needs have at least 3 items (descent, swim, ascent).
     * @param emergencyAscent Not null array of segments representing the special ascent.
     *                 Doesn't have to be part of the segments parameter value, since in emergency we need current state.
     * @param tanks All tanks used to generate the profile, their gases need to fit all used in segments param
     * @param consumptionOptions Not null consumption definition.
     */
    public consumeFromTanks2(segments: Segment[], emergencyAscent: Segment[], tanks: Tank[], consumptionOptions: ConsumptionOptions): void {
        if (segments.length < 2) {
            throw new Error('Profile needs to contain at least 2 segments.');
        }

        Tanks.resetConsumption(tanks);
        // Reserve needs to be first to be able preserve it.
        this.updateReserve(emergencyAscent, tanks, consumptionOptions);
        // First satisfy user defined segments where tank is assigned and only then try the rest.
        const minimum = (t: Tank) => 0;
        const rmv = consumptionOptions.diver.rmv;
        let remainToConsume = this.consumeByTanks(segments, rmv, minimum);
        remainToConsume = this.consumeByGases(segments, tanks, rmv, remainToConsume, minimum);
    }

    /**
     * We cant provide this method for multilevel dives, because we don't know which segment to extend
     * @param sourceSegments User defined profile
     * @param tanks The tanks used during the dive to check available gases
     * @param consumptionOptions Not null consumption definition
     * @param options ppO2 definitions needed to estimate ascent profile
     * @returns Number of minutes representing maximum time we can spend as bottom time.
     * Returns 0 in case the duration is shorter than user defined segments.
     */
    public calculateMaxBottomTime(sourceSegments: Segments, tanks: Tank[],
        consumptionOptions: ConsumptionOptions, options: Options): number {
        const testSegments = this.createTestProfile(sourceSegments);
        const addedSegment = testSegments.last();

        const context: SearchContext = {
            // choosing the step based on typical dive duration
            estimationStep: Time.oneMinute * 40,
            initialValue: 0,
            maxValue: Time.oneDay,
            doWork: (newValue: number) => {
                addedSegment.duration = newValue;
                this.consumeFromProfile(testSegments, tanks, consumptionOptions, options);
            },
            meetsCondition: () => Tanks.haveReserve(tanks)
        };

        const interval = new BinaryIntervalSearch();
        const addedDuration = interval.search(context);

        // the estimated max. duration is shorter, than user defined segments
        if (addedDuration === 0) {
            return 0;
        }

        // Round down to minutes directly to ensure we are in range of enough value
        const totalDuration = Time.toMinutes(sourceSegments.duration + addedDuration);
        return Precision.floor(totalDuration);
    }

    private consumeFromProfile(testSegments: Segments, tanks: Tank[], consumptionOptions: ConsumptionOptions, options: Options) {
        const profile = Consumption.calculateDecompression(testSegments, tanks, options);
        this.consumeFromTanks(profile.segments, options, tanks, consumptionOptions);
    }

    private createTestProfile(sourceSegments: Segments): Segments {
        const testSegments = sourceSegments.copy();
        const lastUserSegment = sourceSegments.last();
        testSegments.addFlat(lastUserSegment.gas, 0);
        return testSegments;
    }

    private updateReserve(ascent: Segment[], tanks: Tank[], options: ConsumptionOptions): void {
        // here the consumed during emergency ascent means reserve
        // take all segments, because we expect all segments are not user defined => don't have tank assigned
        const gasesConsumed: Map<number, number> = this.toBeConsumedYet(ascent, options.diver.teamStressRmv,
            new Map<number, number>(), () => true);

        // add the reserve from opposite order than consumed gas
        for (let index = 0; index <= tanks.length - 1; index++) {
            const tank = tanks[index];
            const gasCode = tank.gas.contentCode();
            let consumedLiters = gasesConsumed.get(gasCode) || 0;
            consumedLiters = this.addReserveToTank(tank, consumedLiters);
            gasesConsumed.set(gasCode, consumedLiters);
            tank.reserve = this.ensureMinimalReserve(tank, index, options);
        }
    }

    private ensureMinimalReserve(tank: Tank, tankIndex: number, options: ConsumptionOptions): number {
        // maybe use the tank.id instead of index
        const minimalReserve = tankIndex === 0 ? options.primaryTankReserve : options.stageTankReserve;

        if(tank.reserve < minimalReserve) {
            return minimalReserve;
        }

        return tank.reserve;
    }

    private addReserveToTank(tank: Tank, consumedLiters: number): number {
        const consumedBars = Precision.ceil(consumedLiters / tank.size);
        const tankConsumedBars = (consumedBars + tank.reserve) > tank.startPressure ? tank.startPressure - tank.reserve : consumedBars;
        tank.reserve += tankConsumedBars;
        return this.extractRemaining(consumedLiters, tankConsumedBars, tank.size);
    }

    private consumeByGases(segments: Segment[], tanks: Tank[], rmv: number, remainToConsume: Map<number, number>,
        minimum: (t: Tank) => number): Map<number, number> {
        // assigned tank will be consumed from that tank directly
        // it is always user defined segment (also in ascent)
        const gasesConsumed: Map<number, number> = this.toBeConsumedYet(segments, rmv, remainToConsume, (s) => !s.tank);

        // distribute the consumed liters across all tanks with that gas starting from last one
        // to consumed stages first. This simulates open circuit procedure: First consume, what you can drop.
        for (let index = tanks.length - 1; index >= 0; index--) {
            const tank = tanks[index];
            const gasCode = tank.gas.contentCode();
            let consumedLiters = gasesConsumed.get(gasCode) || 0;
            consumedLiters = this.consumeFromTank(tank, consumedLiters, minimum);
            gasesConsumed.set(gasCode, consumedLiters);
        }

        return gasesConsumed;
    }

    private consumeByTanks(segments: Segment[], rmv: number, minimum: (t: Tank) => number): Map<number, number> {
        const remainToConsume: Map<number, number> = new Map<number, number>();
        const sacSeconds = Time.toMinutes(rmv);

        segments.forEach((segment: Segment) => {
            if (segment.tank) {
                const tank = segment.tank;
                const gasCode = segment.gas.contentCode();
                const consumptionSegment = ConsumptionSegment.fromSegment(segment);
                const consumedLiters = this.consumedBySegment(consumptionSegment, sacSeconds);
                const remainingLiters = this.consumeFromTank(tank, consumedLiters, minimum);
                let consumedByGas: number = remainToConsume.get(gasCode) || 0;
                consumedByGas += remainingLiters;
                remainToConsume.set(gasCode, consumedByGas);
            }
        });

        return remainToConsume;
    }

    /** Requires already calculated reserve */
    private consumeFromTank(tank: Tank, consumedLiters: number, minimum: (t: Tank) => number): number {
        const consumedBars = Precision.ceil(consumedLiters / tank.size);
        const tankConsumedBars = consumedBars > tank.endPressure ? tank.endPressure : consumedBars;
        // TODO count also with the reserve
        tank.consumed += tankConsumedBars;
        return this.extractRemaining(consumedLiters, tankConsumedBars, tank.size);
    }

    private extractRemaining(consumedLiters: number, tankConsumedBars: number, tankSize: number): number {
        consumedLiters = consumedLiters - (tankConsumedBars * tankSize);
        // because of previous rounding up the consumed bars
        consumedLiters = consumedLiters < 0 ? 0 : consumedLiters;
        return consumedLiters;
    }

    private toBeConsumedYet(segments: Segment[], rmv: number,
        remainToConsume: Map<number, number>,
        includeSegment: (segment: Segment) => boolean): Map<number, number> {

        const rmvSeconds = Time.toMinutes(rmv);

        for (let index = 0; index < segments.length; index++) {
            const segment = segments[index];

            if (includeSegment(segment)) {
                const gas = segment.gas;
                const gasCode = gas.contentCode();
                const converted = ConsumptionSegment.fromSegment(segment);
                const consumedLiters = this.consumedBySegment(converted, rmvSeconds);
                let consumedByGas: number = remainToConsume.get(gasCode) || 0;
                consumedByGas += consumedLiters;
                remainToConsume.set(gasCode, consumedByGas);
            }
        }

        return remainToConsume;
    }

    /**
     * Returns consumption in Liters at given segment average depth
     * @param rmvSeconds Liter/second
     */
    private consumedBySegment(segment: ConsumptionSegment, rmvSeconds: number) {
        const averagePressure = this.depthConverter.toBar(segment.averageDepth);
        const consumed = segment.duration * averagePressure * rmvSeconds;
        return consumed;
    }
}

